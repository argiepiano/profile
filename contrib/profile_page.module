<?php

/**
 * @file
 * Adds separate pages for viewing and editing profiles.
 */

/**
 * Implements hook_menu().
 */
function profile_page_menu() {
  $items = array();

  // Bugfix for uninstalling the module, see http://backdrop.org/node/1008346.
  if (!module_exists('profile')) {
    return;
  }

  foreach (profile_get_types() as $type_name => $type) {
    if (!empty($type->data['use_page'])) {
      $path = profile_page_get_base_path($type);
      $count = count(explode('/', $path));

      $items[$path] = array(
        'title callback' => 'profile_page_title',
        'title arguments' => array($type_name),
        'page callback' => 'profile_page_own',
        'page arguments' => array($path),
        'access callback' => 'user_access',
        'access arguments' => array("view own $type_name profile"),
        'file' => 'profile_page.inc',
        'menu_name' => 'user-menu',
      );

      $items[$path . '/%profile_by_uid'] = array(
        'title callback' => 'profile_page_title',
        'title arguments' => array($type_name, $count),
        'page callback' => 'profile_page_view',
        'page arguments' => array($count),
        'load arguments' => array($type_name),
        'access callback' => 'profile_access',
        'access arguments' => array('view', $count),
        'file' => 'profile_page.inc',
        // Copied over the following hack from user_menu() to avoid $path
        // appearing in the breadcrumb:
        //
        // By assigning a different menu name, this item (and all registered
        // child paths) are no longer considered as children of 'user'. When
        // accessing the user account pages, the preferred menu link that is
        // used to build the active trail (breadcrumb) will be found in this
        // menu (unless there is more specific link), so the link to 'user' will
        // not be in the breadcrumb.
        'menu_name' => 'navigation',
      );
      $items[$path . '/%profile_by_uid/view'] = array(
        'title' => 'View',
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'load arguments' => array($type_name),
        'weight' => -10,
      );
      $items[$path . '/%profile_by_uid/edit'] = array(
        'page callback' => 'entity_ui_get_form',
        'page arguments' => array('profile', $count),
        'load arguments' => array($type_name),
        'access callback' => 'profile_access',
        'access arguments' => array('edit', $count),
        'title' => 'Edit',
        'type' => MENU_LOCAL_TASK,
        'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
        'file' => 'profile_page.inc',
      );
      $items[$path . '/%profile_by_uid/delete'] = array(
        'page callback' => 'backdrop_get_form',
        'page arguments' => array('profile_page_delete_confirm_form', $count),
        'load arguments' => array($type_name),
        'access callback' => 'profile_access',
        'access arguments' => array('delete', $count),
        'title' => 'Delete',
        'type' => MENU_LOCAL_TASK,
        'context' => MENU_CONTEXT_INLINE,
        'file' => 'profile_page.inc',
      );
      // Devel integration.
      if (module_exists('devel')) {
        $devel_path = backdrop_get_path('module', 'devel');
        $items[$path . '/%profile_by_uid/devel'] = array(
          'title' => 'Devel',
          'page callback' => 'devel_load_object',
          'file' => 'devel.pages.inc',
          'file path' => $devel_path,
          'page arguments' => array('profile', $count),
          'access arguments' => array('access devel information'),
          'type' => MENU_LOCAL_TASK,
          'weight' => 100,
        );
        $items[$path . '/%profile_by_uid/devel/load'] = array(
          'title' => 'Load',
          'type' => MENU_DEFAULT_LOCAL_TASK,
        );
        $items[$path . '/%profile_by_uid/devel/render'] = array(
          'title' => 'Render',
          'page callback' => 'devel_render_object',
          'page arguments' => array('profile', $count),
          'access arguments' => array('access devel information'),
          'file' => 'devel.pages.inc',
          'file path' => $devel_path,
          'type' => MENU_LOCAL_TASK,
          'weight' => 100,
        );
      }
    }
  }
  return $items;
}

/**
 * Menu load callback.
 *
 * Returns the profile object for the given user. If there is none yet, a new
 * object is created.
 */
function profile_by_uid_load($uid, $type_name) {
  if ($uid && is_numeric($uid) && ($account = user_load($uid))) {
    $profile = profile_load_by_user($account, $type_name);
    if (!$profile) {
      $profile = profile_create(array('type' => $type_name));
      $profile->setUser($account);
      $profile->is_new = TRUE;
    }
    return $profile;
  }
  return FALSE;
}

/**
 * Returns the base path to use as profile page.
 */
function profile_page_get_base_path($profile_type) {
  // Allow for an easy customization of the page's base path.
  if (!empty($profile_type->data['page_path'])) {
    return $profile_type->data['page_path'];
  }
  return 'profile-' . $profile_type->type;
}

/**
 * Implements hook_forms().
 */
function profile_page_forms($form_id, $args) {
  // For efficiency, only act if the third argument is 'profile'.
  if (isset($args[2]) && is_string($args[2]) && $args[2] == 'profile') {
    $info = entity_get_info('profile');
    // Translate bundle form ids to the base form id 'profile_form'.
    foreach ($info['bundles'] as $bundle => $bundle_info) {
      $forms['profile_edit_' . $bundle . '_form']['callback'] = 'profile_form';
      $forms['profile_edit_' . $bundle . '_form']['wrapper callback'] = 'entity_ui_form_defaults';
    }
    if (!empty($forms)) {
      // Include the file with profile_form() callback. This needed when the
      // form is loaded from the outside, for example, from the ajax callback.
      form_load_include($form_state, 'inc', 'profile_page');
      return $forms;
    }
  }
}

/**
 * Implements hook_profile_type_load().
 */
function profile_page_profile_type_load($types) {
  foreach ($types as $type) {
    if (!empty($type->data['use_page'])) {
      // Disable user categories and the user account view.
      $type->userCategory = FALSE;
      $type->userView = FALSE;
    }
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function profile_page_entity_info_alter(&$entity_info) {
  // Add new view modes for the page.
  $entity_info['profile']['view modes']['page'] = array(
    'label' => t('Profile page'),
     'custom settings' => FALSE,
  );
  $entity_info['profile']['view modes']['teaser'] = array(
    'label' => t('Teaser'),
    'custom settings' => FALSE,
  );
  $entity_info['profile']['uri callback'] = 'profile_page_uri_callback';
  $entity_info['profile']['form callback'] = 'profile_page_form_callback';

  // Integrate with Metatag module to enable metatags support for separate
  // profile pages.
  if (module_exists('metatag')) {
    $entity_info['profile']['metatags'] = TRUE;
  }
}

/**
 * URI callback pointing to the profile page.
 *
 * @see profile_pages_entity_info_alter()
 */
function profile_page_uri_callback($profile) {
  $type = $profile->type();
  if (!empty($type->data['use_page'])) {
    return array('path' => profile_page_get_base_path($type) . '/' . $profile->uid);
  }
  // Fall back to the default callback.
  return $profile->defaultUri();
}

/**
 * Form callback for entity_form().
 */
function profile_page_form_callback($profile) {
  // Pre-populate the form-state with the right form include.
  $form_state = form_state_defaults();
  form_load_include($form_state, 'inc', 'profile_page');
  return entity_ui_get_form('profile', $profile, 'edit', $form_state);
}

/**
 * Menu title callback.
 */
function profile_page_title($type_name, $profile = NULL) {
  $type = profile_get_types($type_name);
  // If no profile is given, we are at the general path pointing to the own
  // profile.
  if (!isset($profile)) {
    return t('My @profile-label', array('@profile-label' => backdrop_strtolower($type->getTranslation('label'))));
  }
  return backdrop_ucfirst($profile->label());
}

/**
 * Implements hook_form_FORM_ID_alter() for the profile type form..
 */
function profile_page_form_profile_type_form_alter(&$form, &$form_state) {
  $type = $form_state['profile_type'];
  $form['data']['use_page'] = array(
    '#type' => 'checkbox',
    '#title' => t('Provide a separate page for editing profiles.'),
    '#description' => t('If enabled, a separate menu item for editing the profile is generated and the profile is hidden from the user account page.'),
    '#default_value' => !empty($type->is_new) || !empty($type->data['use_page']),
  );
  $form['data']['#tree'] = TRUE;
}

/**
 * Implements hook_profile_type_insert().
 */
function profile_page_profile_type_insert(ProfileType $type) {
  // Do not directly issue menu rebuilds here to avoid potentially multiple
  // rebuilds. Instead, let menu_get_item() issue the rebuild on the next page.
  if (!empty($type->data['use_page'])) {
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_profile_type_update().
 */
function profile_page_profile_type_update(ProfileType $type) {
  // Rebuild the menu if use_page or the type name has been changed.
  // @see profile_page_profile_type_insert()
  if (empty($type->data['use_page']) != empty($type->original->data['use_page']) || (!empty($type->data['use_page']) &&  $type->type != $type->original->type)) {
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_profile_type_delete()
 */
function profile_page_profile_type_delete($type) {
  // Do not directly issue menu rebuilds here to avoid potentially multiple
  // rebuilds. Instead, let menu_get_item() issue the rebuild on the next page.
  if (!empty($type->data['use_page'])) {
    state_set('menu_rebuild_needed', TRUE);
  }
}
